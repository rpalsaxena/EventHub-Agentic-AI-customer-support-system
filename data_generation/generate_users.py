"""Generate Users for EventHub

Uses AWS Bedrock (Claude 3 Haiku) to generate realistic user data.

User Schema:
    - user_id: str (e.g., "u_00001") - Generated by Python
    - full_name: str - Generated by LLM
    - email: str - Generated by LLM
    - city: str - Generated by LLM
    - is_blocked: bool - Generated by Python
    - created_at: str (ISO format) - Generated by Python
    - subscription_tier: str (basic/premium) - Generated by Python
    - subscription_status: str (active/cancelled/paused) - Generated by Python
    - monthly_quota: int (5 for basic, 10 for premium) - Generated by Python

Usage:
    python generate_users.py
"""

import random
from datetime import datetime, timedelta
from config import (
    invoke_claude_json_list,
    append_to_jsonl,
    clear_file,
    print_progress,
    DATA_COUNTS,
    BATCH_SIZES,
    OUTPUT_FILES,
)


# ============================================
# ID GENERATOR (Guaranteed Unique)
# ============================================

class IDGenerator:
    """Generates unique sequential IDs."""
    
    def __init__(self, prefix: str = "u"):
        self.prefix = prefix
        self.counter = 0
    
    def next_id(self) -> str:
        """Generate next unique ID."""
        self.counter += 1
        return f"{self.prefix}_{self.counter:05d}"  # u_00001, u_00002, ...
    
    def next_batch(self, count: int) -> list:
        """Generate batch of unique IDs."""
        return [self.next_id() for _ in range(count)]


# Global ID generator
user_id_generator = IDGenerator(prefix="u")

# Global email tracker for uniqueness
generated_emails: set = set()


# ============================================
# PROMPTS (Simplified - No IDs)
# ============================================

SYSTEM_PROMPT = """You are a data generator for EventHub, an event ticketing platform.
Generate realistic user data with diverse names, cities, and email patterns.
Include a mix of:
- Different nationalities (American, Indian, British, etc.)
- Various cities (New York, Mumbai, London, etc.)
- Professional and personal email domains
Return ONLY valid JSON array, no additional text."""


def get_user_prompt(batch_size: int) -> str:
    """Generate prompt for user creation."""
    return f"""Generate {batch_size} unique EventHub users as a JSON array.

Each user should have ONLY these fields:
- full_name: realistic full name (diverse nationalities)
- email: realistic email matching the name (use domains like gmail.com, yahoo.com, outlook.com, company domains)
- city: major city name (diverse locations worldwide)

DO NOT include user_id, is_blocked, or dates - those will be added separately.

Return ONLY the JSON array:
[
  {{"full_name": "John Smith", "email": "john.smith@gmail.com", "city": "New York"}},
  {{"full_name": "Priya Sharma", "email": "priya.sharma@outlook.com", "city": "Mumbai"}},
  ...
]"""


# ============================================
# DATA ENRICHMENT (Python-Generated Fields)
# ============================================

def generate_created_at() -> str:
    """Generate random creation date within last 2 years from today."""
    today = datetime.now()
    two_years_ago = today - timedelta(days=730)  # ~2 years
    
    random_days = random.randint(0, 730)
    random_date = two_years_ago + timedelta(days=random_days)
    
    # Add random time
    random_date = random_date.replace(
        hour=random.randint(0, 23),
        minute=random.randint(0, 59),
        second=random.randint(0, 59)
    )
    
    return random_date.isoformat()


def generate_is_blocked() -> bool:
    """Generate is_blocked status (1% blocked)."""
    return random.random() < 0.01


def assign_subscription(user: dict) -> dict:
    """
    Assign subscription details to a user.
    
    Distribution:
    - 70% basic tier
    - 30% premium tier
    - 85% active, 10% cancelled, 5% paused
    """
    today = datetime.now()
    
    # Tier distribution
    tier = "premium" if random.random() < 0.30 else "basic"
    
    # Status distribution (adjusted for more variety)
    status_roll = random.random()
    if status_roll < 0.85:
        status = "active"
    elif status_roll < 0.95:
        status = "cancelled"
    else:
        status = "paused"
    
    # Quota based on tier
    quota = 10 if tier == "premium" else 5
    
    # Subscription dates
    user_created = datetime.fromisoformat(user["created_at"])
    sub_start = user_created + timedelta(days=random.randint(0, 30))
    
    # End date based on status (must be in the past, not future)
    sub_end = None
    if status == "cancelled" or status == "paused":
        # Calculate max days between sub_start and today
        days_since_start = (today - sub_start).days
        
        if days_since_start > 30:
            # Enough time has passed - set end date in past
            sub_end = sub_start + timedelta(days=random.randint(30, days_since_start))
        else:
            # Subscription too recent to be cancelled/paused - make it active
            status = "active"
    # Active: no end date (null)
    
    user["subscription_tier"] = tier
    user["subscription_status"] = status
    user["monthly_quota"] = quota
    user["subscription_started_at"] = sub_start.isoformat()
    user["subscription_ended_at"] = sub_end.isoformat() if sub_end else None
    
    return user


def enrich_user(user: dict, user_id: str) -> dict:
    """
    Add Python-generated fields to LLM-generated user.
    
    LLM provides: full_name, email, city
    Python adds: user_id, is_blocked, created_at, subscription_*
    
    Email uniqueness: If the email already exists, append user_id to the 
    email label (before @) to ensure uniqueness.
    """
    global generated_emails
    
    email = user["email"]
    
    # Check for duplicate email and make unique if needed
    if email in generated_emails:
        # Split email into local part and domain
        if "@" in email:
            local_part, domain = email.rsplit("@", 1)
            email = f"{local_part}_{user_id}@{domain}"
        else:
            # Fallback for malformed email
            email = f"{email}_{user_id}"
    
    # Track this email
    generated_emails.add(email)
    
    enriched = {
        "user_id": user_id,
        "full_name": user["full_name"],
        "email": email,
        "city": user["city"],
        "is_blocked": generate_is_blocked(),
        "created_at": generate_created_at(),
    }
    
    # Add subscription details
    enriched = assign_subscription(enriched)
    
    return enriched


# ============================================
# MAIN GENERATION
# ============================================

def generate_users(rewrite: bool = False):
    """
    Generate users using Claude 3 Haiku.
    
    Args:
        rewrite: If True, clears existing file. If False (default), appends to existing data.
    """
    
    total_users = DATA_COUNTS["users"]
    batch_size = BATCH_SIZES["users"]
    output_file = OUTPUT_FILES["users"]
    
    # Handle append vs rewrite mode
    if rewrite:
        print(f"\nðŸ”„ REWRITE MODE: Clearing existing data")
        clear_file(output_file)
        user_id_generator.counter = 0  # Reset ID counter
        generated_emails.clear()  # Reset email tracker
    else:
        # Append mode: Resume from existing count and load existing emails
        if output_file.exists():
            from config import load_from_jsonl
            existing_users = load_from_jsonl(output_file)
            existing_count = len(existing_users)
            user_id_generator.counter = existing_count  # Resume ID counter
            
            # Load existing emails into tracker for uniqueness check
            for user in existing_users:
                if "email" in user:
                    generated_emails.add(user["email"])
            
            print(f"\nðŸ“‚ APPEND MODE: Found {existing_count:,} existing users, resuming...")
            print(f"   Loaded {len(generated_emails):,} emails for uniqueness tracking")
        else:
            print(f"\nðŸ“‚ APPEND MODE: No existing file, starting fresh...")
    
    print(f"ðŸš€ Generating {total_users:,} users...")
    print(f"   Batch size: {batch_size}")
    print(f"   Total batches: {total_users // batch_size}")
    print(f"   Output: {output_file}\n")
    
    generated_count = 0
    batch_num = 1
    
    while generated_count < total_users:
        # Adjust batch size for last batch
        current_batch_size = min(batch_size, total_users - generated_count)
        
        try:
            # Generate batch via LLM (only name, email, city)
            prompt = get_user_prompt(current_batch_size)
            users_from_llm = invoke_claude_json_list(prompt, SYSTEM_PROMPT)
            
            # Generate unique IDs for this batch
            user_ids = user_id_generator.next_batch(len(users_from_llm))
            
            # Enrich with Python-generated fields
            enriched_users = [
                enrich_user(user, user_id) 
                for user, user_id in zip(users_from_llm, user_ids)
            ]
            
            # Save batch
            append_to_jsonl(enriched_users, output_file)
            
            generated_count += len(enriched_users)
            print_progress(generated_count, total_users, "Users")
            
        except Exception as e:
            print(f"\nâŒ Error in batch {batch_num}: {e}")
            print("   Retrying...")
            continue
        
        batch_num += 1
    
    print(f"\nâœ… Generated {generated_count:,} users to {output_file}")


# ============================================
# ENTRY POINT
# ============================================

if __name__ == "__main__":
    import sys
    
    # Parse command line arguments
    rewrite_mode = "--rewrite" in sys.argv
    test_mode = "--test" in sys.argv
    
    if test_mode:
        print("ðŸ§ª TEST MODE: Generating 10 users only")
        DATA_COUNTS["users"] = 10
        BATCH_SIZES["users"] = 10
    
    if rewrite_mode:
        print("ðŸ”„ REWRITE MODE: Will clear existing data")
    else:
        print("ðŸ“‚ APPEND MODE: Will add to existing data (use --rewrite to clear)")
    
    generate_users(rewrite=rewrite_mode)
