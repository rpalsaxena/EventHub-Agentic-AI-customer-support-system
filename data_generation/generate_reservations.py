"""Generate Reservations for EventHub

Uses Python to generate realistic reservation/booking data.
Links users to events with proper constraints.

Reservation Schema:
    - reservation_id: str (e.g., "r_00001") - Generated by Python
    - user_id: str - Linked to existing user
    - event_id: str - Linked to existing event
    - ticket_count: int - Number of tickets (1-6)
    - total_price: float - Based on event pricing
    - status: str - confirmed/cancelled/pending
    - booking_date: str - Date reservation was made
    - payment_method: str - credit_card/paypal/apple_pay
    - is_premium: bool - Premium member discount applied

Distribution:
    - 5000 reservations total
    - Active users have 1-10 reservations
    - Premium users have 20% discount applied
    - 85% confirmed, 10% cancelled, 5% pending

Edge Cases Handled:
    - No reservations for events that are cancelled
    - Tickets sold doesn't exceed event capacity
    - Booking date is before event date
    - Premium users get discounted rates
    - No duplicate user+event bookings (same user can't book same event twice)
    - Premium events only bookable by premium users
    - Blocked users have all reservations cancelled
    - Booking date respects user's subscription dates

Usage:
    python generate_reservations.py           # Append mode (default)
    python generate_reservations.py --rewrite # Clear and regenerate
    python generate_reservations.py --test    # Generate 100 reservations only
"""

import random
from datetime import datetime, timedelta
from collections import defaultdict
from config import (
    append_to_jsonl,
    clear_file,
    load_from_jsonl,
    print_progress,
    OUTPUT_FILES,
)


# ============================================
# CONFIGURATION
# ============================================

RESERVATION_COUNT = 5000
RESERVATION_BATCH_SIZE = 500  # Save in batches

# Status distribution
STATUS_DISTRIBUTION = {
    "confirmed": 0.85,
    "cancelled": 0.10,
    "pending": 0.05,
}

PAYMENT_METHODS = ["credit_card", "paypal", "apple_pay", "google_pay"]
PAYMENT_WEIGHTS = [0.60, 0.20, 0.15, 0.05]

PREMIUM_DISCOUNT = 0.20  # 20% discount for premium members


# ============================================
# TRACKING STATE (for edge case handling)
# ============================================

# Track (user_id, event_id) pairs to prevent duplicate bookings
booked_pairs: set = set()

# Track tickets sold per event to respect capacity
event_tickets_sold: dict = defaultdict(int)


# ============================================
# ID GENERATOR
# ============================================

class IDGenerator:
    def __init__(self, prefix: str = "r"):
        self.prefix = prefix
        self.counter = 0
    
    def next_id(self) -> str:
        self.counter += 1
        return f"{self.prefix}_{self.counter:05d}"


reservation_id_generator = IDGenerator(prefix="r")


# ============================================
# HELPER FUNCTIONS
# ============================================

def generate_status() -> str:
    """Generate reservation status based on distribution."""
    roll = random.random()
    cumulative = 0
    for status, prob in STATUS_DISTRIBUTION.items():
        cumulative += prob
        if roll < cumulative:
            return status
    return "confirmed"


def generate_booking_date(event_date_str: str, user: dict | None = None) -> str:
    """Generate booking date that's before event date and respects user subscription."""
    event_date = datetime.strptime(event_date_str, "%Y-%m-%d")
    today = datetime.now()
    
    # Determine earliest possible booking date
    earliest_booking = today - timedelta(days=365)  # Default: up to 1 year ago
    
    # If user has subscription dates, booking must be after subscription started
    if user:
        sub_started = user.get("subscription_started_at")
        if sub_started:
            try:
                sub_start_date = datetime.strptime(sub_started[:10], "%Y-%m-%d")
                earliest_booking = max(earliest_booking, sub_start_date)
            except:
                pass
    
    # Booking must be before event date
    latest_booking = min(event_date - timedelta(days=1), today)
    
    # Handle edge case: if earliest > latest, use latest
    if earliest_booking >= latest_booking:
        booking_date = latest_booking - timedelta(days=random.randint(1, 30))
    else:
        # Random date between earliest and latest
        days_range = (latest_booking - earliest_booking).days
        if days_range > 0:
            random_days = random.randint(0, days_range)
            booking_date = earliest_booking + timedelta(days=random_days)
        else:
            booking_date = earliest_booking
    
    # Ensure not in future
    if booking_date > today:
        booking_date = today - timedelta(days=random.randint(1, 30))
    
    return booking_date.strftime("%Y-%m-%d")


def calculate_price(event: dict, ticket_count: int, is_premium_user: bool) -> float:
    """Calculate total price with optional premium discount."""
    price_min = event.get("price_min", 25.0)
    price_max = event.get("price_max", 75.0)
    
    # Random price between min and max
    unit_price = random.uniform(price_min, price_max)
    total = unit_price * ticket_count
    
    # Apply premium discount
    if is_premium_user:
        total = total * (1 - PREMIUM_DISCOUNT)
    
    return round(total, 2)


def create_reservation(user: dict, event: dict, ticket_count: int) -> dict:
    """Create a single reservation linking user to event."""
    
    is_premium = user.get("subscription_tier") == "premium"
    is_blocked = user.get("is_blocked", False)
    
    # Blocked users have all reservations cancelled
    if is_blocked:
        status = "cancelled"
    else:
        status = generate_status()
    
    return {
        "reservation_id": reservation_id_generator.next_id(),
        "user_id": user["user_id"],
        "user_email": user["email"],
        "event_id": event["event_id"],
        "event_title": event["title"],
        "venue_id": event.get("venue_id", ""),
        "venue_name": event.get("venue_name", ""),
        "event_date": event["event_date"],
        "ticket_count": ticket_count,
        "total_price": calculate_price(event, ticket_count, is_premium),
        "status": status,
        "booking_date": generate_booking_date(event["event_date"], user),
        "payment_method": random.choices(PAYMENT_METHODS, PAYMENT_WEIGHTS)[0],
        "is_premium_booking": is_premium,
    }


def can_book_event(user: dict, event: dict, ticket_count: int) -> bool:
    """Check if user can book this event (all edge cases)."""
    
    user_id = user["user_id"]
    event_id = event["event_id"]
    
    # Edge Case 1: No duplicate bookings (same user + same event)
    if (user_id, event_id) in booked_pairs:
        return False
    
    # Edge Case 2: Capacity check
    event_capacity = event.get("total_tickets", 500)
    if event_tickets_sold[event_id] + ticket_count > event_capacity:
        return False
    
    # Edge Case 3: Premium events only for premium users
    if event.get("is_premium", False):
        if user.get("subscription_tier") != "premium":
            return False
    
    return True


def record_booking(user_id: str, event_id: str, ticket_count: int):
    """Record a booking to track state."""
    booked_pairs.add((user_id, event_id))
    event_tickets_sold[event_id] += ticket_count


# ============================================
# MAIN GENERATION
# ============================================

def generate_reservations(rewrite: bool = False, test_mode: bool = False):
    """Generate reservations linking users to events."""
    
    global booked_pairs, event_tickets_sold
    
    output_file = OUTPUT_FILES["reservations"]
    users_file = OUTPUT_FILES["users"]
    events_file = OUTPUT_FILES["events"]
    
    # Load users
    if not users_file.exists():
        print("âŒ Error: users.jsonl not found. Run generate_users.py first!")
        return
    users = load_from_jsonl(users_file)
    print(f"ğŸ“‚ Loaded {len(users)} users")
    
    # Load events
    if not events_file.exists():
        print("âŒ Error: events.jsonl not found. Run generate_events.py first!")
        return
    events = load_from_jsonl(events_file)
    print(f"ğŸ“‚ Loaded {len(events)} events")
    
    # Filter out cancelled events
    active_events = [e for e in events if e.get("status") != "cancelled"]
    print(f"   {len(active_events)} events are bookable (not cancelled)")
    
    # Separate premium and non-premium events
    premium_events = [e for e in active_events if e.get("is_premium", False)]
    regular_events = [e for e in active_events if not e.get("is_premium", False)]
    print(f"   {len(premium_events)} premium events, {len(regular_events)} regular events")
    
    # Separate users by tier and status
    premium_users = [u for u in users if u.get("subscription_tier") == "premium" 
                     and u.get("subscription_status") == "active"]
    basic_users = [u for u in users if u.get("subscription_tier") == "basic"
                   and u.get("subscription_status") == "active"]
    inactive_users = [u for u in users if u.get("subscription_status") != "active"]
    blocked_users = [u for u in users if u.get("is_blocked", False)]
    
    print(f"   {len(premium_users)} premium users, {len(basic_users)} basic users")
    print(f"   {len(inactive_users)} inactive users, {len(blocked_users)} blocked users")
    
    # Build event lookup for capacity tracking
    event_lookup = {e["event_id"]: e for e in active_events}
    
    # Handle append vs rewrite mode
    if rewrite:
        print(f"\nğŸ”„ REWRITE MODE: Clearing existing reservations")
        clear_file(output_file)
        reservation_id_generator.counter = 0
        booked_pairs = set()
        event_tickets_sold = defaultdict(int)
    else:
        if output_file.exists():
            existing = load_from_jsonl(output_file)
            reservation_id_generator.counter = len(existing)
            # Rebuild tracking state from existing data
            for res in existing:
                booked_pairs.add((res["user_id"], res["event_id"]))
                event_tickets_sold[res["event_id"]] += res.get("ticket_count", 1)
            print(f"\nğŸ“‚ APPEND MODE: Found {len(existing)} existing reservations")
    
    total_reservations = 100 if test_mode else RESERVATION_COUNT
    print(f"\nğŸš€ Generating {total_reservations} reservations...")
    print(f"   Output: {output_file}\n")
    
    reservations = []
    generated_count = 0
    attempts = 0
    max_attempts = total_reservations * 10  # Prevent infinite loops
    
    while generated_count < total_reservations and attempts < max_attempts:
        attempts += 1
        
        # Decide user pool (80% active, 15% inactive, 5% blocked)
        roll = random.random()
        if roll < 0.05 and blocked_users:
            user = random.choice(blocked_users)
            eligible_events = regular_events  # Blocked users only had regular events
        elif roll < 0.20 and inactive_users:
            user = random.choice(inactive_users)
            eligible_events = regular_events
        elif premium_users and random.random() < 0.40:
            # Premium users can book both premium and regular events
            user = random.choice(premium_users)
            eligible_events = active_events
        else:
            # Basic users can only book regular events
            user = random.choice(basic_users) if basic_users else random.choice(users)
            eligible_events = regular_events if regular_events else active_events
        
        if not eligible_events:
            continue
        
        event = random.choice(eligible_events)
        
        # Generate ticket count
        ticket_count = random.choices(
            [1, 2, 3, 4, 5, 6],
            weights=[0.30, 0.35, 0.15, 0.10, 0.05, 0.05]
        )[0]
        
        # Check all edge cases
        if not can_book_event(user, event, ticket_count):
            continue
        
        # Create and record reservation
        reservation = create_reservation(user, event, ticket_count)
        record_booking(user["user_id"], event["event_id"], ticket_count)
        
        reservations.append(reservation)
        generated_count += 1
        
        # Save in batches
        if len(reservations) >= RESERVATION_BATCH_SIZE:
            append_to_jsonl(reservations, output_file)
            print_progress(generated_count, total_reservations, "Reservations")
            reservations = []
    
    # Save remaining
    if reservations:
        append_to_jsonl(reservations, output_file)
        print_progress(generated_count, total_reservations, "Reservations")
    
    # Print stats
    print(f"\nâœ… Generated {generated_count} reservations to {output_file}")
    print(f"   Unique user-event pairs: {len(booked_pairs)}")
    print(f"   Events with bookings: {len(event_tickets_sold)}")
    
    if attempts >= max_attempts:
        print(f"âš ï¸  Stopped early due to constraints (max attempts reached)")


# ============================================
# ENTRY POINT
# ============================================

if __name__ == "__main__":
    import sys
    
    rewrite_mode = "--rewrite" in sys.argv
    test_mode = "--test" in sys.argv
    
    if test_mode:
        print("ğŸ§ª TEST MODE: Generating 100 reservations only")
    
    if rewrite_mode:
        print("ğŸ”„ REWRITE MODE: Will clear existing data")
    else:
        print("ğŸ“‚ APPEND MODE: Will add to existing data (use --rewrite to clear)")
    
    generate_reservations(rewrite=rewrite_mode, test_mode=test_mode)
