"""Generate Events for EventHub

Uses AWS Bedrock (Claude 3 Haiku) to generate realistic event data.
Events are linked to venues and distributed across SF Bay Area.

Event Schema:
    - event_id: str (e.g., "e_00001") - Generated by Python
    - title: str - Generated by LLM
    - description: str - Generated by LLM
    - venue_id: str - Linked to existing venue
    - category: str - Matches venue category
    - event_date: str - Generated by Python (upcoming dates)
    - start_time: str - Generated by Python
    - duration_minutes: int - Generated by Python
    - price_min: float - Generated by Python
    - price_max: float - Generated by Python
    - total_tickets: int - Based on venue capacity
    - tickets_sold: int - Generated by Python
    - is_premium: bool - Generated by Python (30% premium)
    - status: str - active/cancelled/soldout

Distribution:
    - 400 events total across 40 venues (~10 events per venue)
    - Mix of upcoming dates (next 6 months)
    - 70% available, 20% sold out, 10% cancelled

Usage:
    python generate_events.py           # Append mode (default)
    python generate_events.py --rewrite # Clear and regenerate
    python generate_events.py --test    # Generate 10 events only
"""

import random
from datetime import datetime, timedelta
from config import (
    invoke_claude_json_list,
    append_to_jsonl,
    clear_file,
    load_from_jsonl,
    print_progress,
    OUTPUT_FILES,
)


# ============================================
# CONFIGURATION
# ============================================

EVENT_COUNT = 400
EVENT_BATCH_SIZE = 20  # Events per LLM call

# Event status distribution
STATUS_DISTRIBUTION = {
    "active": 0.70,     # 70% available
    "soldout": 0.20,    # 20% sold out
    "cancelled": 0.10,  # 10% cancelled
}


# ============================================
# ID GENERATOR
# ============================================

class IDGenerator:
    def __init__(self, prefix: str = "e"):
        self.prefix = prefix
        self.counter = 0
    
    def next_id(self) -> str:
        self.counter += 1
        return f"{self.prefix}_{self.counter:05d}"
    
    def next_batch(self, count: int) -> list:
        return [self.next_id() for _ in range(count)]


event_id_generator = IDGenerator(prefix="e")


# ============================================
# PROMPTS
# ============================================

SYSTEM_PROMPT = """You are a data generator for EventHub, an event ticketing platform in the San Francisco Bay Area.
Generate realistic event titles and descriptions that would appear on a ticketing website.
Make events sound exciting and appealing to Bay Area audiences.
Return ONLY valid JSON array, no additional text."""


def get_event_prompt(count: int, category: str, venue_name: str, city: str) -> str:
    """Generate prompt for event creation."""
    
    category_examples = {
        "music": "concerts, live bands, DJ nights, album release parties, tribute shows",
        "theater": "plays, musicals, Broadway tours, one-person shows, dance performances",
        "comedy": "stand-up specials, improv nights, comedy tours, open mic nights",
        "art": "gallery openings, art exhibitions, interactive installations, artist talks",
        "sports": "games, tournaments, watch parties, fitness events, championships",
        "conference": "tech talks, networking events, workshops, summits, meetups",
    }
    
    examples = category_examples.get(category, "various events")
    
    return f"""Generate {count} realistic {category} events for "{venue_name}" in {city} as a JSON array.

Event types to include: {examples}

Each event should have ONLY these fields:
- title: Catchy, realistic event title (e.g., "Jazz Night with The Blue Notes", "Tech Startup Summit 2025")
- description: 2-3 sentence compelling description that would appear on a ticket page

Make titles specific and interesting, not generic.
Include some well-known performers/artists names (realistic but fictional).
Reference local Bay Area culture where appropriate.

Return ONLY the JSON array:
[
  {{"title": "Summer Jazz Festival", "description": "Join us for an unforgettable evening of smooth jazz..."}},
  ...
]"""


# ============================================
# DATA ENRICHMENT
# ============================================

def generate_event_date() -> str:
    """Generate random event date within next 6 months."""
    today = datetime.now()
    max_days = 180  # 6 months ahead
    random_days = random.randint(1, max_days)
    event_date = today + timedelta(days=random_days)
    return event_date.strftime("%Y-%m-%d")


def generate_start_time() -> str:
    """Generate realistic event start time."""
    # Most events are in evening, some afternoon
    hour_weights = {
        10: 0.05, 11: 0.05, 12: 0.05,  # Morning/early afternoon
        14: 0.10, 15: 0.10, 16: 0.10,  # Afternoon
        18: 0.15, 19: 0.20, 20: 0.15, 21: 0.05  # Evening
    }
    hour = random.choices(list(hour_weights.keys()), weights=list(hour_weights.values()))[0]
    minute = random.choice([0, 30])
    return f"{hour:02d}:{minute:02d}"


def generate_duration(category: str) -> int:
    """Generate realistic event duration in minutes."""
    duration_ranges = {
        "music": (90, 180),
        "theater": (120, 180),
        "comedy": (60, 120),
        "art": (120, 240),
        "sports": (120, 240),
        "conference": (180, 480),
    }
    min_dur, max_dur = duration_ranges.get(category, (90, 180))
    return random.randint(min_dur // 30, max_dur // 30) * 30  # Round to 30 min


def generate_pricing(category: str, is_premium: bool) -> tuple:
    """Generate min and max ticket prices."""
    base_prices = {
        "music": (25, 75),
        "theater": (40, 120),
        "comedy": (20, 50),
        "art": (15, 35),
        "sports": (30, 100),
        "conference": (50, 200),
    }
    min_base, max_base = base_prices.get(category, (25, 75))
    
    # Premium events cost more
    if is_premium:
        min_base = int(min_base * 1.5)
        max_base = int(max_base * 2)
    
    price_min = random.randint(min_base, min_base + 20)
    price_max = random.randint(max_base, max_base + 50)
    
    return float(price_min), float(price_max)


def generate_ticket_sales(total_tickets: int, status: str) -> int:
    """Generate tickets sold based on status."""
    if status == "soldout":
        return total_tickets
    elif status == "cancelled":
        return random.randint(0, int(total_tickets * 0.3))
    else:  # active
        return random.randint(int(total_tickets * 0.1), int(total_tickets * 0.9))


def generate_status() -> str:
    """Generate event status based on distribution."""
    roll = random.random()
    cumulative = 0
    for status, prob in STATUS_DISTRIBUTION.items():
        cumulative += prob
        if roll < cumulative:
            return status
    return "active"


def enrich_event(event: dict, event_id: str, venue: dict) -> dict:
    """Add Python-generated fields to LLM-generated event."""
    
    category = venue["category"]
    is_premium = random.random() < 0.30  # 30% premium events
    status = generate_status()
    
    # Total tickets based on venue capacity (don't fill to max)
    total_tickets = random.randint(
        int(venue["capacity"] * 0.5),
        int(venue["capacity"] * 0.95)
    )
    
    price_min, price_max = generate_pricing(category, is_premium)
    
    return {
        "event_id": event_id,
        "title": event["title"],
        "description": event["description"],
        "venue_id": venue["venue_id"],
        "venue_name": venue["name"],
        "city": venue["city"],
        "neighborhood": venue["neighborhood"],
        "category": category,
        "event_date": generate_event_date(),
        "start_time": generate_start_time(),
        "duration_minutes": generate_duration(category),
        "price_min": price_min,
        "price_max": price_max,
        "total_tickets": total_tickets,
        "tickets_sold": generate_ticket_sales(total_tickets, status),
        "is_premium": is_premium,
        "status": status,
    }


# ============================================
# MAIN GENERATION
# ============================================

def generate_events(rewrite: bool = False, test_mode: bool = False):
    """Generate events linked to venues using Claude 3 Haiku."""
    
    output_file = OUTPUT_FILES["events"]
    venues_file = OUTPUT_FILES["venues"]
    
    # Load venues first
    if not venues_file.exists():
        print("âŒ Error: venues.jsonl not found. Run generate_venues.py first!")
        return
    
    venues = load_from_jsonl(venues_file)
    if not venues:
        print("âŒ Error: No venues found. Run generate_venues.py first!")
        return
    
    print(f"ğŸ“‚ Loaded {len(venues)} venues")
    
    # Handle append vs rewrite mode
    if rewrite:
        print(f"ğŸ”„ REWRITE MODE: Clearing existing events")
        clear_file(output_file)
        event_id_generator.counter = 0
    else:
        if output_file.exists():
            existing = load_from_jsonl(output_file)
            event_id_generator.counter = len(existing)
            print(f"ğŸ“‚ APPEND MODE: Found {len(existing)} existing events")
    
    # Calculate events per venue
    total_events = 10 if test_mode else EVENT_COUNT
    events_per_venue = max(1, total_events // len(venues))
    
    print(f"\nğŸš€ Generating ~{total_events} events ({events_per_venue} per venue)...")
    print(f"   Output: {output_file}\n")
    
    generated_count = 0
    
    for venue in venues:
        venue_events_count = events_per_venue if not test_mode else min(2, events_per_venue)
        
        # Limit batches
        if test_mode and generated_count >= 10:
            break
        
        try:
            prompt = get_event_prompt(
                venue_events_count,
                venue["category"],
                venue["name"],
                venue["city"]
            )
            events_from_llm = invoke_claude_json_list(prompt, SYSTEM_PROMPT)
            
            # Generate unique IDs
            event_ids = event_id_generator.next_batch(len(events_from_llm))
            
            # Enrich events with venue info
            enriched_events = [
                enrich_event(event, event_id, venue)
                for event, event_id in zip(events_from_llm, event_ids)
            ]
            
            # Save batch
            append_to_jsonl(enriched_events, output_file)
            
            generated_count += len(enriched_events)
            print_progress(generated_count, total_events, "Events")
            
        except Exception as e:
            print(f"\nâŒ Error generating events for {venue['name']}: {e}")
            print("   Skipping venue...")
            continue
    
    print(f"\nâœ… Generated {generated_count} events to {output_file}")


# ============================================
# ENTRY POINT
# ============================================

if __name__ == "__main__":
    import sys
    
    rewrite_mode = "--rewrite" in sys.argv
    test_mode = "--test" in sys.argv
    
    if test_mode:
        print("ğŸ§ª TEST MODE: Generating 10 events only")
    
    if rewrite_mode:
        print("ğŸ”„ REWRITE MODE: Will clear existing data")
    else:
        print("ğŸ“‚ APPEND MODE: Will add to existing data (use --rewrite to clear)")
    
    generate_events(rewrite=rewrite_mode, test_mode=test_mode)
