"""Generate Support Tickets for EventHub

Uses AWS Bedrock (Claude 3 Haiku) to generate realistic customer support tickets.
Links to users, events, and reservations for realistic scenarios.

Ticket Schema:
    - ticket_id: str (e.g., "t_00001") - Generated by Python
    - user_id: str - Linked to existing user
    - user_email: str - For agent reference
    - category: str - refund/cancellation/technical/general/complaint
    - subject: str - Generated by LLM
    - description: str - Generated by LLM
    - reservation_id: str - Optional, linked reservation
    - event_id: str - Optional, related event
    - status: str - open/in_progress/resolved/escalated
    - priority: str - low/medium/high/urgent
    - created_at: str - Ticket creation date
    - resolved_at: str - Optional, resolution date
    - agent_notes: str - Optional, internal notes

Distribution:
    - 500 tickets total
    - 40% refund requests
    - 25% cancellation issues
    - 15% technical problems
    - 10% general inquiries
    - 10% complaints

Usage:
    python generate_tickets.py           # Append mode (default)
    python generate_tickets.py --rewrite # Clear and regenerate
    python generate_tickets.py --test    # Generate 20 tickets only
"""

import random
from datetime import datetime, timedelta
from config import (
    invoke_claude_json_list,
    append_to_jsonl,
    clear_file,
    load_from_jsonl,
    print_progress,
    OUTPUT_FILES,
)


# ============================================
# CONFIGURATION
# ============================================

TICKET_COUNT = 500
TICKET_BATCH_SIZE = 25  # Tickets per LLM call

# Category distribution
TICKET_CATEGORIES = {
    "refund": {"weight": 0.40, "high_priority": 0.30},
    "cancellation": {"weight": 0.25, "high_priority": 0.20},
    "technical": {"weight": 0.15, "high_priority": 0.40},
    "general": {"weight": 0.10, "high_priority": 0.05},
    "complaint": {"weight": 0.10, "high_priority": 0.60},
}

# Status distribution
STATUS_DISTRIBUTION = {
    "open": 0.30,
    "in_progress": 0.25,
    "resolved": 0.35,
    "escalated": 0.10,
}

PRIORITY_LEVELS = ["low", "medium", "high", "urgent"]


# ============================================
# ID GENERATOR
# ============================================

class IDGenerator:
    def __init__(self, prefix: str = "t"):
        self.prefix = prefix
        self.counter = 0
    
    def next_id(self) -> str:
        self.counter += 1
        return f"{self.prefix}_{self.counter:05d}"
    
    def next_batch(self, count: int) -> list:
        return [self.next_id() for _ in range(count)]


ticket_id_generator = IDGenerator(prefix="t")


# ============================================
# PROMPTS
# ============================================

SYSTEM_PROMPT = """You are a data generator for EventHub, an event ticketing platform.
Generate realistic customer support ticket subjects and descriptions.
Write as if you are a frustrated or confused customer reaching out for help.
Include specific details that make the issue feel real.
Return ONLY valid JSON array, no additional text."""


def get_ticket_prompt(count: int, category: str, context: dict | None = None) -> str:
    """Generate prompt for ticket creation."""
    
    category_scenarios = {
        "refund": """Refund requests - customers wanting money back for:
            - Event cancellation
            - Unable to attend due to personal reasons
            - Tickets purchased by mistake
            - Duplicate purchases
            - Changed event dates that don't work for them""",
            
        "cancellation": """Cancellation issues - customers having problems with:
            - How to cancel their reservation
            - Cancellation policy questions
            - Cancellation fees being too high
            - Deadline confusion for cancellations
            - Subscription cancellation requests""",
            
        "technical": """Technical problems - customers experiencing:
            - Unable to log in to account
            - Payment processing errors
            - Tickets not showing in app
            - QR code not scanning
            - Website/app crashes
            - Email notifications not received""",
            
        "general": """General inquiries - customers asking about:
            - Venue accessibility information
            - Group booking discounts
            - Premium membership benefits
            - Gift cards and vouchers
            - Age restrictions for events
            - Parking and transportation""",
            
        "complaint": """Complaints - customers unhappy about:
            - Poor customer service experience
            - Long wait times at venue
            - Event quality not as advertised
            - Seating issues
            - Hidden fees discovered at checkout
            - Premium benefits not working"""
    }
    
    scenario = category_scenarios.get(category, "general support issues")
    event_info = ""
    
    if context and context.get("event_title"):
        event_info = f'\nReference this event when relevant: "{context["event_title"]}" at {context.get("venue_name", "the venue")}'
    
    return f"""Generate {count} realistic customer support tickets for the "{category}" category as a JSON array.

Scenarios to cover:
{scenario}
{event_info}

Each ticket should have ONLY these fields:
- subject: Brief ticket subject line (5-10 words, like an email subject)
- description: Customer's detailed message (2-4 sentences, written from customer's perspective)

Make descriptions feel authentic with:
- Specific (but fictional) dates and amounts
- Emotional language when appropriate
- Mix of polite and frustrated tones
- Real-sounding issues customers would face

Return ONLY the JSON array:
[
  {{"subject": "Refund request for cancelled concert", "description": "I purchased 2 tickets for the jazz concert on March 15th but it was cancelled. I haven't received my refund of $75 yet. It's been 2 weeks and I'm very frustrated..."}},
  ...
]"""


# ============================================
# DATA ENRICHMENT
# ============================================

def generate_status() -> str:
    """Generate ticket status based on distribution."""
    roll = random.random()
    cumulative = 0.0
    for status, prob in STATUS_DISTRIBUTION.items():
        cumulative += prob
        if roll < cumulative:
            return status
    return "open"


def generate_priority(category: str) -> str:
    """Generate priority based on category."""
    config = TICKET_CATEGORIES.get(category, {"high_priority": 0.10})
    
    if random.random() < config["high_priority"]:
        return random.choice(["high", "urgent"])
    else:
        return random.choices(
            ["low", "medium"],
            weights=[0.30, 0.70]
        )[0]


def generate_dates(status: str) -> tuple:
    """Generate created_at and resolved_at dates."""
    today = datetime.now()
    
    # Tickets created in last 30 days
    days_ago = random.randint(0, 30)
    created_at = today - timedelta(days=days_ago)
    
    resolved_at = None
    if status == "resolved":
        # Resolved 1-7 days after creation
        resolution_days = random.randint(1, min(7, days_ago))
        resolved_at = created_at + timedelta(days=resolution_days)
        if resolved_at > today:
            resolved_at = today
    
    return (
        created_at.strftime("%Y-%m-%d %H:%M:%S"),
        resolved_at.strftime("%Y-%m-%d %H:%M:%S") if resolved_at else None
    )


def generate_agent_notes(status: str, category: str) -> str | None:
    """Generate optional agent notes for resolved/escalated tickets."""
    if status == "open":
        return None
    
    notes_templates = {
        "refund": [
            "Verified purchase. Refund processed to original payment method.",
            "Event was cancelled. Full refund approved per policy.",
            "Partial refund issued due to late cancellation request.",
            "Customer bought wrong date. Exchanged tickets instead of refund.",
        ],
        "cancellation": [
            "Explained cancellation policy. Customer understood.",
            "Processed cancellation request. No fees applied (24h+ notice).",
            "Cancellation fee waived as goodwill gesture.",
            "Subscription cancelled per customer request. Retained until end of billing cycle.",
        ],
        "technical": [
            "Password reset link sent. Issue resolved.",
            "Duplicate account merged. Tickets transferred successfully.",
            "Payment retry successful after clearing browser cache.",
            "Resent confirmation email. Customer confirmed receipt.",
        ],
        "complaint": [
            "Offered complimentary tickets for future event as compensation.",
            "Escalated to venue management for review.",
            "Issued $20 credit to account as apology.",
            "Customer was satisfied after detailed explanation.",
        ],
        "general": [
            "Provided requested information via email.",
            "Connected customer with venue accessibility coordinator.",
            "Upgraded to premium trial as requested.",
            "Question answered. No further action needed.",
        ],
    }
    
    if status in ["resolved", "in_progress", "escalated"]:
        templates = notes_templates.get(category, notes_templates["general"])
        return random.choice(templates)
    
    return None


def select_category() -> str:
    """Select ticket category based on distribution."""
    categories = list(TICKET_CATEGORIES.keys())
    weights = [TICKET_CATEGORIES[c]["weight"] for c in categories]
    return random.choices(categories, weights=weights)[0]


def enrich_ticket(ticket: dict, ticket_id: str, category: str, 
                  user: dict, reservation: dict | None = None, event: dict | None = None) -> dict:
    """Add Python-generated fields to LLM-generated ticket."""
    
    status = generate_status()
    created_at, resolved_at = generate_dates(status)
    
    enriched = {
        "ticket_id": ticket_id,
        "user_id": user["user_id"],
        "user_email": user["email"],
        "category": category,
        "subject": ticket["subject"],
        "description": ticket["description"],
        "status": status,
        "priority": generate_priority(category),
        "created_at": created_at,
        "resolved_at": resolved_at,
        "agent_notes": generate_agent_notes(status, category),
    }
    
    # Add reservation reference if applicable (only if reservation belongs to user)
    if reservation and reservation.get("user_id") == user["user_id"]:
        enriched["reservation_id"] = reservation["reservation_id"]
        enriched["event_id"] = reservation.get("event_id")
        enriched["event_title"] = reservation.get("event_title")
    elif event:
        # Add event reference if applicable
        enriched["event_id"] = event["event_id"]
        enriched["event_title"] = event["title"]
    
    return enriched


# ============================================
# MAIN GENERATION
# ============================================

def generate_tickets(rewrite: bool = False, test_mode: bool = False):
    """Generate support tickets using Claude 3 Haiku."""
    
    output_file = OUTPUT_FILES["tickets"]
    users_file = OUTPUT_FILES["users"]
    events_file = OUTPUT_FILES["events"]
    reservations_file = OUTPUT_FILES["reservations"]
    
    # Load dependencies
    if not users_file.exists():
        print("âŒ Error: users.jsonl not found. Run generate_users.py first!")
        return
    users = load_from_jsonl(users_file)
    print(f"ðŸ“‚ Loaded {len(users)} users")
    
    # Build user lookup for quick access
    user_lookup = {u["user_id"]: u for u in users}
    
    events = []
    event_lookup = {}
    if events_file.exists():
        events = load_from_jsonl(events_file)
        event_lookup = {e["event_id"]: e for e in events}
        print(f"ðŸ“‚ Loaded {len(events)} events")
    
    reservations = []
    user_reservations = {}  # Map user_id -> list of their reservations
    if reservations_file.exists():
        reservations = load_from_jsonl(reservations_file)
        # Build user -> reservations mapping for proper linking
        for res in reservations:
            uid = res.get("user_id")
            if uid not in user_reservations:
                user_reservations[uid] = []
            user_reservations[uid].append(res)
        print(f"ðŸ“‚ Loaded {len(reservations)} reservations")
        print(f"   {len(user_reservations)} users have reservations")
    
    # Handle append vs rewrite mode
    if rewrite:
        print(f"\nðŸ”„ REWRITE MODE: Clearing existing tickets")
        clear_file(output_file)
        ticket_id_generator.counter = 0
    else:
        if output_file.exists():
            existing = load_from_jsonl(output_file)
            ticket_id_generator.counter = len(existing)
            print(f"\nðŸ“‚ APPEND MODE: Found {len(existing)} existing tickets")
    
    total_tickets = 20 if test_mode else TICKET_COUNT
    print(f"\nðŸš€ Generating {total_tickets} support tickets...")
    print(f"   Output: {output_file}\n")
    
    generated_count = 0
    
    # Generate tickets by category
    while generated_count < total_tickets:
        category = select_category()
        batch_size = min(TICKET_BATCH_SIZE, total_tickets - generated_count)
        
        # For refund/cancellation tickets, prefer users who have reservations
        if category in ["refund", "cancellation"] and user_reservations:
            users_with_bookings = [u for u in users if u["user_id"] in user_reservations]
            user_pool = users_with_bookings if users_with_bookings else users
        else:
            user_pool = users
        
        # Get random event for context
        context = {}
        event = random.choice(events) if events else None
        if event:
            context = {
                "event_title": event["title"],
                "venue_name": event.get("venue_name", ""),
            }
        
        try:
            prompt = get_ticket_prompt(batch_size, category, context)
            tickets_from_llm = invoke_claude_json_list(prompt, SYSTEM_PROMPT)
            
            # Generate unique IDs
            ticket_ids = ticket_id_generator.next_batch(len(tickets_from_llm))
            
            # Enrich tickets
            enriched_tickets = []
            for ticket, ticket_id in zip(tickets_from_llm, ticket_ids):
                user = random.choice(user_pool)
                
                # Get user's actual reservation if they have one
                reservation = None
                if user["user_id"] in user_reservations:
                    user_res_list = user_reservations[user["user_id"]]
                    if user_res_list and random.random() < 0.7:
                        reservation = random.choice(user_res_list)
                        # Get the event from the reservation
                        event = event_lookup.get(reservation.get("event_id"))
                
                enriched = enrich_ticket(
                    ticket, ticket_id, category, user, reservation, event
                )
                enriched_tickets.append(enriched)
            
            # Save batch
            append_to_jsonl(enriched_tickets, output_file)
            
            generated_count += len(enriched_tickets)
            print_progress(generated_count, total_tickets, "Tickets")
            
        except Exception as e:
            print(f"\nâŒ Error generating tickets: {e}")
            print("   Retrying...")
            continue
    
    print(f"\nâœ… Generated {generated_count} tickets to {output_file}")


# ============================================
# ENTRY POINT
# ============================================

if __name__ == "__main__":
    import sys
    
    rewrite_mode = "--rewrite" in sys.argv
    test_mode = "--test" in sys.argv
    
    if test_mode:
        print("ðŸ§ª TEST MODE: Generating 20 tickets only")
    
    if rewrite_mode:
        print("ðŸ”„ REWRITE MODE: Will clear existing data")
    else:
        print("ðŸ“‚ APPEND MODE: Will add to existing data (use --rewrite to clear)")
    
    generate_tickets(rewrite=rewrite_mode, test_mode=test_mode)
